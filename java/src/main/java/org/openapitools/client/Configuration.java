/*
 * Cost API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 2.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client;

import org.openapitools.client.kubeconfig.KubeConfigAuth;
import org.openapitools.client.kubeconfig.KubeConfigUtils;
import java.io.IOException;
import java.util.Objects;
import java.util.concurrent.atomic.AtomicReference;
import java.util.function.Supplier;
import java.io.StringReader;
import org.bouncycastle.openssl.PEMParser;
import org.bouncycastle.openssl.PEMKeyPair;
import org.bouncycastle.openssl.jcajce.JcaPEMKeyConverter;

@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2025-10-15T18:44:41.522481+08:00[Asia/Shanghai]", comments = "Generator version: 7.16.0")
public class Configuration {
  public static final String VERSION = "2.0.0";

  private static final AtomicReference<ApiClient> defaultApiClient = new AtomicReference<>();
  private static volatile Supplier<ApiClient> apiClientFactory = ApiClient::new;

  /**
   * Get the default API client, which would be used when creating API instances without providing an API client.
   *
   * @return Default API client
   */
  public static ApiClient getDefaultApiClient() {
    ApiClient client = defaultApiClient.get();
    if (client == null) {
      client = defaultApiClient.updateAndGet(val -> {
        if (val != null) { // changed by another thread
          return val;
        }
        return apiClientFactory.get();
      });
    }
    return client;
  }

  /**
   * Set the default API client, which would be used when creating API instances without providing an API client.
   *
   * @param apiClient API client
   */
  public static void setDefaultApiClient(ApiClient apiClient) {
    defaultApiClient.set(apiClient);
  }

  /**
   * set the callback used to create new ApiClient objects
   */
  public static void setApiClientFactory(Supplier<ApiClient> factory) {
    apiClientFactory = Objects.requireNonNull(factory);
  }

  private Configuration() {
  }

  /**
   * Create a new ApiClient with kubeconfig support
   * 
   * @param kubeconfigPath Path to kubeconfig file. If null, tries default locations
   * @return ApiClient configured with kubeconfig authentication
   * @throws IOException if kubeconfig cannot be loaded
   */
  public static ApiClient newApiClientWithKubeconfig(String kubeconfigPath) throws IOException {
    KubeConfigAuth auth = KubeConfigUtils.extractAuthFromKubeconfig(kubeconfigPath);
    ApiClient client = new ApiClient();
    
    // Set the base URL from kubeconfig
    client.setBasePath(auth.getServerUrl());
    
    // Configure SSL settings
    if (auth.isInsecureSkip()) {
      client.setVerifyingSsl(false);
    } else {
      client.setVerifyingSsl(true);
      
      // Configure client certificates first
      if (auth.getCertData() != null && auth.getKeyData() != null) {
        try {
          // Create KeyManager for client certificates
          javax.net.ssl.KeyManager[] keyManagers = createKeyManagers(auth.getCertData(), auth.getKeyData());
          client.setKeyManagers(keyManagers);
        } catch (Exception e) {
          throw new IOException("Failed to configure client certificates: " + e.getMessage(), e);
        }
      }
      
      // Configure CA certificate
      if (auth.getCaData() != null && auth.getCaData().length > 0) {
        try {
          java.io.ByteArrayInputStream caInputStream = new java.io.ByteArrayInputStream(auth.getCaData());
          client.setSslCaCert(caInputStream);
        } catch (Exception e) {
          System.err.println("Warning: Failed to configure CA certificate: " + e.getMessage());
          // Continue without CA certificate - will use default trust store
        }
      }
    }
    
    return client;
  }

  /**
   * Create a new ApiClient with kubeconfig support and proxy path
   * 
   * @param kubeconfigPath Path to kubeconfig file. If null, tries default locations
   * @param proxyPath Proxy path to append to the server URL
   * @return ApiClient configured with kubeconfig authentication and proxy
   * @throws IOException if kubeconfig cannot be loaded
   */
  public static ApiClient newApiClientWithKubeconfigAndProxy(String kubeconfigPath, String proxyPath) throws IOException {
    ApiClient client = newApiClientWithKubeconfig(kubeconfigPath);
    
    // Update base path to include proxy path
    if (proxyPath != null && !proxyPath.isEmpty()) {
      String basePath = client.getBasePath();
      if (!proxyPath.startsWith("/")) {
        proxyPath = "/" + proxyPath;
      }
      client.setBasePath(basePath + proxyPath);
    }
    
    return client;
  }

  /**
   * Create KeyManagers from certificate and key data
   * 
   * @param certData Certificate data
   * @param keyData Key data
   * @return Array of KeyManagers
   * @throws Exception if KeyManagers cannot be created
   */
  private static javax.net.ssl.KeyManager[] createKeyManagers(byte[] certData, byte[] keyData) throws Exception {
    // Create temporary files for certificate and key
    java.io.File certFile = java.io.File.createTempFile("client-cert", ".pem");
    java.io.File keyFile = java.io.File.createTempFile("client-key", ".pem");
    
    try {
      // Write certificate data to file
      java.nio.file.Files.write(certFile.toPath(), certData);
      
      // Write key data to file
      java.nio.file.Files.write(keyFile.toPath(), keyData);
      
      // Create KeyStore
      java.security.KeyStore keyStore = java.security.KeyStore.getInstance("PKCS12");
      keyStore.load(null, null);
      
      // Load certificate and key
      java.security.cert.CertificateFactory certFactory = java.security.cert.CertificateFactory.getInstance("X.509");
      java.util.Collection<? extends java.security.cert.Certificate> certificates = certFactory.generateCertificates(new java.io.FileInputStream(certFile));
      
      if (certificates.isEmpty()) {
        throw new Exception("No certificates found in certificate data");
      }
      
      java.security.cert.Certificate cert = certificates.iterator().next();
      
      // Load private key
      java.security.PrivateKey privateKey = loadPrivateKey(keyFile);
      
      // Add to keystore
      keyStore.setKeyEntry("client", privateKey, null, new java.security.cert.Certificate[]{cert});
      
      // Create KeyManagerFactory
      javax.net.ssl.KeyManagerFactory kmf = javax.net.ssl.KeyManagerFactory.getInstance(
          javax.net.ssl.KeyManagerFactory.getDefaultAlgorithm());
      kmf.init(keyStore, null);
      
      return kmf.getKeyManagers();
    } finally {
      // Clean up temporary files
      certFile.delete();
      keyFile.delete();
    }
  }

  /**
   * Load private key from file using BouncyCastle
   * 
   * @param keyFile Key file
   * @return PrivateKey
   * @throws Exception if key cannot be loaded
   */
  private static java.security.PrivateKey loadPrivateKey(java.io.File keyFile) throws Exception {
    String keyContent = new String(java.nio.file.Files.readAllBytes(keyFile.toPath()));
    
    try (PEMParser pemParser = new PEMParser(new StringReader(keyContent))) {
      Object object = pemParser.readObject();
      
      if (object instanceof PEMKeyPair) {
        PEMKeyPair keyPair = (PEMKeyPair) object;
        JcaPEMKeyConverter converter = new JcaPEMKeyConverter();
        return converter.getPrivateKey(keyPair.getPrivateKeyInfo());
      } else if (object instanceof org.bouncycastle.asn1.pkcs.PrivateKeyInfo) {
        org.bouncycastle.asn1.pkcs.PrivateKeyInfo privateKeyInfo = (org.bouncycastle.asn1.pkcs.PrivateKeyInfo) object;
        JcaPEMKeyConverter converter = new JcaPEMKeyConverter();
        return converter.getPrivateKey(privateKeyInfo);
      } else {
        throw new Exception("Unsupported private key format: " + object.getClass().getName());
      }
    } catch (Exception e) {
      throw new Exception("Failed to parse private key: " + e.getMessage(), e);
    }
  }

}