/*
Cost API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 2.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)

// DefaultAPIService DefaultAPI service
type DefaultAPIService service

type ApiGetAllocationRequest struct {
	ctx        context.Context
	ApiService *DefaultAPIService
	window     *string
	filter     *string
	step       *string
	aggregate  *string
	idle       *bool
	shareIdle  *bool
	shareSplit *string
	idleByNode *bool
	format     *string
}

// The time range to be queried.
func (r ApiGetAllocationRequest) Window(window string) ApiGetAllocationRequest {
	r.window = &window
	return r
}

// The filter options for workloads.
func (r ApiGetAllocationRequest) Filter(filter string) ApiGetAllocationRequest {
	r.filter = &filter
	return r
}

// The interval that is used to split the time range.
func (r ApiGetAllocationRequest) Step(step string) ApiGetAllocationRequest {
	r.step = &step
	return r
}

// The aggregate options for the returned results from different dimensions.
func (r ApiGetAllocationRequest) Aggregate(aggregate string) ApiGetAllocationRequest {
	r.aggregate = &aggregate
	return r
}

// Specifies whether to display or process idle costs.
func (r ApiGetAllocationRequest) Idle(idle bool) ApiGetAllocationRequest {
	r.idle = &idle
	return r
}

// Specifies whether to allocate idle costs to each resource.
func (r ApiGetAllocationRequest) ShareIdle(shareIdle bool) ApiGetAllocationRequest {
	r.shareIdle = &shareIdle
	return r
}

// The idle cost allocation policy.
func (r ApiGetAllocationRequest) ShareSplit(shareSplit string) ApiGetAllocationRequest {
	r.shareSplit = &shareSplit
	return r
}

// Specifies whether to aggregate idle costs of each node. This parameter takes effect only if you set the aggregate parameter to node and the shareIdle parameter to false.
func (r ApiGetAllocationRequest) IdleByNode(idleByNode bool) ApiGetAllocationRequest {
	r.idleByNode = &idleByNode
	return r
}

// The format that is used to export costs.
func (r ApiGetAllocationRequest) Format(format string) ApiGetAllocationRequest {
	r.format = &format
	return r
}

func (r ApiGetAllocationRequest) Execute() (*AllocationSetRange, *http.Response, error) {
	return r.ApiService.GetAllocationExecute(r)
}

/*
GetAllocation Compute allocation

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetAllocationRequest
*/
func (a *DefaultAPIService) GetAllocation(ctx context.Context) ApiGetAllocationRequest {
	return ApiGetAllocationRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return AllocationSetRange
func (a *DefaultAPIService) GetAllocationExecute(r ApiGetAllocationRequest) (*AllocationSetRange, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AllocationSetRange
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.GetAllocation")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/allocation"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.window == nil {
		return localVarReturnValue, nil, reportError("window is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "window", r.window, "form", "")
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "form", "")
	}
	if r.step != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "step", r.step, "form", "")
	}
	if r.aggregate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "aggregate", r.aggregate, "form", "")
	}
	if r.idle != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "idle", r.idle, "form", "")
	} else {
		var defaultValue bool = true
		r.idle = &defaultValue
	}
	if r.shareIdle != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "shareIdle", r.shareIdle, "form", "")
	} else {
		var defaultValue bool = false
		r.shareIdle = &defaultValue
	}
	if r.shareSplit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "shareSplit", r.shareSplit, "form", "")
	} else {
		var defaultValue string = "weighted"
		r.shareSplit = &defaultValue
	}
	if r.idleByNode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "idleByNode", r.idleByNode, "form", "")
	} else {
		var defaultValue bool = false
		r.idleByNode = &defaultValue
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	} else {
		var defaultValue string = "json"
		r.format = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCostRequest struct {
	ctx        context.Context
	ApiService *DefaultAPIService
	window     *string
	filter     *string
	step       *string
	aggregate  *string
	idle       *bool
	shareIdle  *bool
	shareSplit *string
	idleByNode *bool
	format     *string
}

// The time range to be queried.
func (r ApiGetCostRequest) Window(window string) ApiGetCostRequest {
	r.window = &window
	return r
}

// The filter options for workloads.
func (r ApiGetCostRequest) Filter(filter string) ApiGetCostRequest {
	r.filter = &filter
	return r
}

// The interval that is used to split the time range.
func (r ApiGetCostRequest) Step(step string) ApiGetCostRequest {
	r.step = &step
	return r
}

// The aggregate options for the returned results from different dimensions.
func (r ApiGetCostRequest) Aggregate(aggregate string) ApiGetCostRequest {
	r.aggregate = &aggregate
	return r
}

// Specifies whether to display or process idle costs.
func (r ApiGetCostRequest) Idle(idle bool) ApiGetCostRequest {
	r.idle = &idle
	return r
}

// Specifies whether to allocate idle costs to each resource.
func (r ApiGetCostRequest) ShareIdle(shareIdle bool) ApiGetCostRequest {
	r.shareIdle = &shareIdle
	return r
}

// The idle cost allocation policy.
func (r ApiGetCostRequest) ShareSplit(shareSplit string) ApiGetCostRequest {
	r.shareSplit = &shareSplit
	return r
}

// Specifies whether to aggregate idle costs of each node. This parameter takes effect only if you set the aggregate parameter to node and the shareIdle parameter to false.
func (r ApiGetCostRequest) IdleByNode(idleByNode bool) ApiGetCostRequest {
	r.idleByNode = &idleByNode
	return r
}

// The format that is used to export costs.
func (r ApiGetCostRequest) Format(format string) ApiGetCostRequest {
	r.format = &format
	return r
}

func (r ApiGetCostRequest) Execute() (*AllocationSetRange, *http.Response, error) {
	return r.ApiService.GetCostExecute(r)
}

/*
GetCost Get estimated cost

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetCostRequest
*/
func (a *DefaultAPIService) GetCost(ctx context.Context) ApiGetCostRequest {
	return ApiGetCostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return AllocationSetRange
func (a *DefaultAPIService) GetCostExecute(r ApiGetCostRequest) (*AllocationSetRange, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AllocationSetRange
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.GetCost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/cost"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.window == nil {
		return localVarReturnValue, nil, reportError("window is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "window", r.window, "form", "")
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "form", "")
	}
	if r.step != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "step", r.step, "form", "")
	}
	if r.aggregate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "aggregate", r.aggregate, "form", "")
	}
	if r.idle != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "idle", r.idle, "form", "")
	} else {
		var defaultValue bool = true
		r.idle = &defaultValue
	}
	if r.shareIdle != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "shareIdle", r.shareIdle, "form", "")
	} else {
		var defaultValue bool = false
		r.shareIdle = &defaultValue
	}
	if r.shareSplit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "shareSplit", r.shareSplit, "form", "")
	} else {
		var defaultValue string = "weighted"
		r.shareSplit = &defaultValue
	}
	if r.idleByNode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "idleByNode", r.idleByNode, "form", "")
	} else {
		var defaultValue bool = false
		r.idleByNode = &defaultValue
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	} else {
		var defaultValue string = "json"
		r.format = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
